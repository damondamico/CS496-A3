<!DOCTYPE html>
<html>
<meta charset="utf-8">
<style>
  svg {
    width: 1280px;
    height: 720px;
  }
</style>

<body>
  <svg></svg>
</body>

<script src="http://d3js.org/d3.v6.min.js"></script>

<FORM>
  <INPUT TYPE="Button" value="Average Play Time" onclick="update_plots(playtime)"/>
  <INPUT TYPE="Button" value="Used Price" onclick="update_plots(used_price)"/>
  <INPUT TYPE="Button" value="Genre" onclick="update_plots(genre_one)"/>
  <INPUT TYPE="Button" value="Publisher" onclick="update_plots(publishers_one)"/>
  <INPUT TYPE="Button" value="Platform" onclick="update_plots(release_console)"/>
</FORM>

<script>
  var total_width = 1280, total_height = 720;
  var margin = {top: 20, right: 20, bottom: 20, left: 20}, width = total_width - margin.left - margin.right, height = total_height - margin.top - margin.bottom
  var svg1 = d3.select("svg").append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
  var svg2 = d3.select("svg").append("g").attr("transform", "translate(" + margin.left + "," + margin.top*10 + ")");

  let data;
  var game_titles=[], max_players=[], genre_all=[], genre_one=[], publishers_all=[], publishers_one=[], review_scores=[], sales=[], used_price=[], release_console=[], rating=[], release_year=[], playtime=[];
  ready();

  async function ready() {
      // load files async; store the values so we can use them later
      data = await d3.json("videogame_data.json");
      split_data();
      //test
      make_plot(svg1, playtime, sales); 
      make_plot(svg2, playtime, review_scores);
    }

  function make_plot(svg_to_use, x_feature, y_feature) 
  {
    var scaling = (d3.max(x_feature) > d3.max(y_feature) ? width / d3.max(x_feature) : height / d3.max(y_feature));
    var new_width = d3.max(x_feature) * scaling;
    var new_height = d3.max(y_feature) * scaling;

    var xScale = d3.scaleLinear()
    .domain([d3.min(x_feature), d3.max(x_feature)]) 
    .range([0, new_width]);

    var yScale = d3.scaleLinear()
    .domain([d3.min(y_feature), d3.max(y_feature)]) 
    .range([new_height, 0]);

    var xAxis = d3.axisBottom().scale(xScale); 
    var yAxis = d3.axisLeft().scale(yScale);

    svg_to_use.append("g").attr("class", "xaxis").call(xAxis).attr("transform", "translate(0," + new_height + ")");
    svg_to_use.append("g").attr("class", "yaxis").call(yAxis);

    var dataset_to_use = make_dataset(x_feature, y_feature);
    svg_to_use.selectAll("circle") 
      .data(dataset_to_use)
      .enter().append("circle") 
          .attr("cx", function(d) { return xScale(d[0]); })
          .attr("cy", function(d) { return yScale(d[1]); })
          .attr("r",  5);     
  }

  function update_plots(x_feature){
    var data1 = make_dataset(x_feature,sales);
    var data2 = make_dataset(x_feature,review_scores);
    
    var scaling1 = (d3.max(x_feature) > d3.max(sales) ? width / d3.max(x_feature) : height / d3.max(sales));
    var new_width1 = d3.max(x_feature) * scaling1;
    var new_height1 = d3.max(sales) * scaling1;

    var xScale1 = d3.scaleLinear()
    .domain([d3.min(x_feature), d3.max(x_feature)]) 
    .range([0, new_width1]);

    var yScale1 = d3.scaleLinear()
    .domain([d3.min(sales), d3.max(sales)]) 
    .range([new_height1, 0]);

    var xAxis1 = d3.axisBottom().scale(xScale1); 
    var yAxis1 = d3.axisLeft().scale(yScale1);

    var scaling2 = (d3.max(x_feature) > d3.max(review_scores) ? width / d3.max(x_feature) : height / d3.max(review_scores));
    var new_width2 = d3.max(x_feature) * scaling2;
    var new_height2 = d3.max(review_scores) * scaling2;

    var xScale2 = d3.scaleLinear()
    .domain([d3.min(x_feature), d3.max(x_feature)]) 
    .range([0, new_width2]);

    var yScale2 = d3.scaleLinear()
    .domain([d3.min(review_scores), d3.max(review_scores)]) 
    .range([new_height2, 0]);

    var xAxis2 = d3.axisBottom().scale(xScale2); 
    var yAxis2 = d3.axisLeft().scale(yScale2);

    svg1.selectAll(".yaxis")
        .call(yAxis1);
    svg1.selectAll(".xaxis")
        .call(xAxis1)
        .attr("transform", "translate(0," + new_height1 + ")");
    svg1.selectAll('circle')
      .data(data1)
      .attr("cx", function(d) { return xScale1(d[0]); })
      .attr("cy", function(d) { return yScale1(d[1]); });
    
    svg2.selectAll(".yaxis")
        .call(yAxis2);
    svg2.selectAll(".xaxis")
        .call(xAxis2)
        .attr("transform", "translate(0," + new_height2 + ")");
    svg2.selectAll('circle')
      .data(data2)
      .attr("cx", function(d) { return xScale2(d[0]); })
      .attr("cy", function(d) { return yScale2(d[1]); });

  }


  function make_dataset(x_feature, y_feature)
  {
    var dataset = []
    for (i=0; i<x_feature.length; i++)
    {
      dataset.push([x_feature[i], y_feature[i]]);
    }
    return dataset;
  }

  function split_data() 
  {
    for (i=0; i<data.game.length; i++)
      {
        game_titles.push(data.game[i].name);
        max_players.push(data.game[i].max_players);
        genre_all.push(data.game[i].genre_all);
        genre_one.push(data.game[i].genre_one);
        publishers_all.push(data.game[i].publishers_all);
        publishers_one.push(data.game[i].publishers_one);
        review_scores.push(data.game[i].review_score);
        sales.push(data.game[i].sales);
        used_price.push(data.game[i].used_price);
        release_console.push(data.game[i].release_console);
        rating.push(data.game[i].rating);
        release_year.push(data.game[i].release_year);
        playtime.push(data.game[i].length);
      } 
  }

</script>


</html>
