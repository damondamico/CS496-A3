<!DOCTYPE html>
<html>
<meta charset="utf-8">
<style>
  svg {
    width: 1500px;
    height: 720px;
  }
</style>

<body>
  <svg></svg>
</body>

<script src="http://d3js.org/d3.v6.min.js"></script>

<FORM>
  <INPUT TYPE="Button" value="Average Play Time" onclick="update_plots(playtime)"/>
  <INPUT TYPE="Button" value="Used Price" onclick="update_plots(used_price)"/>
  <INPUT TYPE="Button" value="Genre" onclick="update_plots(genre_one)"/>
  <INPUT TYPE="Button" value="Publisher" onclick="update_plots(publishers_one)"/>
  <INPUT TYPE="Button" value="Platform" onclick="update_plots(release_console)"/>
</FORM>

<script>
  var total_width = 1500, total_height = 720;
  var margin = {top: 20, right: 20, bottom: 20, left: 20}, left_space = 100, top_space = 0;
  var width = 0.9 * (total_width - margin.left - margin.right) / 2, height = 0.9 * (total_height - margin.top - margin.bottom);
  var svg_sales = d3.select("svg").append("g").attr("transform", "translate(" + (left_space + margin.left) + "," + (top_space + margin.top) + ")");
  var svg_reviewscores = d3.select("svg").append("g").attr("transform", "translate(" + (left_space + margin.left + width + margin.right + margin.left) + "," + (top_space + margin.top) + ")");

  let data;
  var game_titles=[], max_players=[], genre_all=[], genre_one=[], publishers_all=[], publishers_one=[], review_scores=[], sales=[], used_price=[], release_console=[], rating=[], release_year=[], playtime=[];
  var all_genres = ["Simulation", "Racing / Driving", "Role-Playing (RPG)", "Action", "Sports", "Educational", "Strategy", "Adventure"];
  var all_publishers = ["Nintendo", "Rockstar", "Microsoft", "Activision", "Sony", "EA", "Ubisoft", "Disney", "2K", "Midway",
             "Sega", "Capcom", "THQ", "Null", "SquareEnix", "Konami", "Namco", "Eidos", "Atari"];
  var all_consoles = ["Nintendo Wii", "X360", "Nintendo DS", "Playstation 3", "Sony PSP"];
  ready();

  async function ready() {
      // load files async; store the values so we can use them later
      data = await d3.json("videogame_data.json");
      split_data();
      //test
      make_plot(svg_sales, playtime, sales); 
      make_plot(svg_reviewscores, playtime, review_scores);
    }

  function make_plot(svg_to_use, x_feature, y_feature) 
  {
    var scaling = get_scaling(x_feature, y_feature);
    var xAxis = d3.axisBottom().scale(scaling.x); 
    var yAxis = d3.axisLeft().scale(scaling.y);

    svg_to_use.append("g").attr("class", "xaxis").call(xAxis).attr("transform", "translate(0," + height + ")");
    svg_to_use.append("g").attr("class", "yaxis").call(yAxis);

    var dataset_to_use = make_dataset(x_feature, y_feature);
    svg_to_use.selectAll("circle") 
      .data(dataset_to_use)
      .enter().append("circle") 
          .attr("cx", function(d) { return scaling.x(d[0]); })
          .attr("cy", function(d) { return scaling.y(d[1]); })
          .attr("r",  5);     
  }

  function update_plots(x_feature){
    svg_sales.selectAll("*").remove();
    svg_reviewscores.selectAll("*").remove();
    make_plot(svg_sales, x_feature, sales); 
    make_plot(svg_reviewscores, x_feature, review_scores);
  }

  function get_scaling(x_feature, y_feature)
  {
    /*var base_scaling = (d3.max(x_feature) > d3.max(y_feature) ? width / d3.max(x_feature) : height / d3.max(y_feature));
    var new_width = d3.max(x_feature) * base_scaling;
    var new_height = d3.max(y_feature) * base_scaling;*/

    //Get correct scaling for the given feature
    switch(x_feature[0])
    {
      case playtime[0]:
        var xScale = d3.scaleLinear()
        .domain([d3.min(x_feature), d3.max(x_feature)]) 
        .range([0, width]);
        var yScale = d3.scaleLinear()
        .domain([d3.min(y_feature), d3.max(y_feature)]) 
        .range([height, 0]);
        break;
      case used_price[0]:
        //something
        break;
      case genre_one[0]:
        //something
        break;
      case publishers_one[0]:
        //something
        break;
      case release_console[0]:
        //something
        break;
      default:
        break;
    }

    return {x: xScale, y: yScale};
  }

  function make_dataset(x_feature, y_feature)
  {
    var dataset = []
    for (i=0; i<x_feature.length; i++)
    {
      dataset.push([x_feature[i], y_feature[i]]);
    }
    return dataset;
  }

  function split_data() 
  {
    for (i=0; i<data.game.length; i++)
      {
        game_titles.push(data.game[i].name);
        max_players.push(data.game[i].max_players);
        genre_all.push(data.game[i].genre_all);
        genre_one.push(data.game[i].genre_one);
        publishers_all.push(data.game[i].publishers_all);
        publishers_one.push(data.game[i].publishers_one);
        review_scores.push(data.game[i].review_score);
        sales.push(data.game[i].sales);
        used_price.push(data.game[i].used_price);
        release_console.push(data.game[i].release_console);
        rating.push(data.game[i].rating);
        release_year.push(data.game[i].release_year);
        playtime.push(data.game[i].length);
      } 
  }

</script>


</html>
